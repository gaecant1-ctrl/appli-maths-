<!DOCTYPE html>
<html lang="fr">
<head>
<script src="https://unpkg.com/twemoji@14.0.2/dist/twemoji.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <meta charset="utf-8">
  <title>Appli Ã©lÃ¨ve â€“ GÃ©omÃ©trie dâ€™emojis ğŸ“</title>
  <style>
body {
  margin: 0;
  font-family: sans-serif;
  display: flex;
  align-items: stretch;
  height: 100vh;
  background: #fff;
}

/* Zone figure */
#geo {
  position: relative;
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #eef7ff;
  border: 3px solid #444;
  border-radius: 20px;
  margin: 10px;
  box-sizing: border-box;
  overflow: hidden;
}
#plateau {
  position: absolute;
  background: transparent;
  border: none;
}
#figure {
  position: absolute;
  display: grid;
  transition: all 0.2s ease-in-out;
}


.cell {
  display: flex;
  align-items: center;       /* âœ… centrage vertical */
  justify-content: center;   /* âœ… centrage horizontal */
  background: #eef7ff;       /* âœ… mÃªme fond que #geo pour masquer les trames */
  margin: 0;
  padding: 0;
  border: none;
  box-sizing: border-box;
  line-height: 1;
        /* âœ… taille relative recalculÃ©e en JS */
  transform: translateZ(0);  /* âœ… force le rendu GPU pour limiter les artefacts */
  image-rendering: -webkit-optimize-contrast;
  -webkit-font-smoothing: antialiased;
}



.bar {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  color: #fff;
  border-radius: 4px;
}
.bar.top { height: 6px; }
.bar.left { width: 4px; }
.cell.ghost {
  color: rgba(0,0,0,0.3);
  filter: grayscale(80%);
  transition: color 0.3s, filter 0.3s;
}

/* Zone contrÃ´le */
#sidebar {
  width: 320px;
  background: linear-gradient(160deg, #ff9800, #e53935);
  color: #fff;
  padding: 12px;
  box-sizing: border-box;
  border: 3px solid #444;
  border-radius: 20px;
  margin: 10px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  display: flex;
  flex-direction: column;
  font-size: 0.85rem;
}
#sidebar h2 {
  font-size: 1.2rem;
  margin: 0 0 8px 0;
  text-align: center;
  font-weight: bold;
}
.section {
  background: rgba(255,255,255,0.15);
  border: 2px solid #fff;
  border-radius: 10px;
  padding: 6px;
  margin-bottom: 8px;
}
.section h3 {
  margin: 0 0 6px 0;
  font-size: 0.9rem;
  text-align: center;
  color: #fff;
}
.param-container {
  display: grid;
  grid-template-columns: repeat(5, 1fr); /* âœ… 5 colonnes fixes */
  gap: 6px;
}

.param-item {
  display: flex;
  flex-direction: column;
  align-items: center;      /* âœ… centre le label + input */
  font-size: 0.8rem;
  text-align: center;
}

.param-item label {
  margin-bottom: 2px;
  font-size: 0.75rem;
  white-space: nowrap;      /* âœ… Ã©vite les retours Ã  la ligne */
}

.param-item input {
  font-size: 0.85rem;
  width: 100%;
  padding: 3px 0;
  border-radius: 6px;
  text-align: center;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

input[type="number"], select, button {
  font-size: 0.8rem;
  width: 100%;
  padding: 4px;
  box-sizing: border-box;
  text-align: center;
  border-radius: 6px;
  border: none;
  outline: none;
}
button {
  background: #fff;
  color: #e53935;
  font-weight: bold;
  cursor: pointer;
  transition: box-shadow 0.2s;
}
button:hover { box-shadow: 0 0 6px rgba(0,0,0,0.3); }

.section.dual {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
  padding: 0;
  border: none;
  background: none;
}
.shuffleZone {
  flex: 0 0 25%;
  display: flex;
  justify-content: center;
  gap: 6px;
  background: rgba(255,255,255,0.15);
  border: 2px solid #fff;
  border-radius: 10px;
  padding: 6px;
}
.shuffleZone button {
  width: 36px; height: 36px; font-size: 1.1rem;
  line-height: 1; padding: 0; text-align: center;
}
#modeZone {
  flex: 1 1 50%;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-content: center;
  gap: 6px;
  background: rgba(255,255,255,0.15);
  border: 2px solid #fff;
  border-radius: 10px;
  padding: 6px;
  box-sizing: border-box;
  min-width: 0;
}
#modeZone button.emoji-toggle {
  flex: 0 0 auto;
  width: 36px; height: 36px; font-size: 1.2rem;
  line-height: 1; padding: 0; border: 2px solid #fff;
  background: #fff; color: #000; text-align: center;
}
#modeZone button.emoji-toggle[data-active="0"] { opacity: 0.4; }

#toggleQBtn {
  margin: 4px auto 6px auto;
  width: 90%;
  background: #ffd54f;
  color: #000;
  font-size: 0.85rem;
  border-radius: 6px;
}
#questionBlock {
  display: none;
  background: rgba(0,0,0,0.15);
  border-radius: 10px;
  padding: 10px;
  margin-top: 6px;
  text-align: center;
}

#questionBlock h3 {
  font-size: 1rem;
  margin: 0 0 8px;
  text-align: center;
  font-weight: bold;
  color: #ffd54f;
  text-shadow: 1px 1px 2px #000;
}

#question {
  text-align: center;
  font-size: 1rem;
  margin-bottom: 8px;
}

/* âœ… Input centrÃ© et stable */
#reponse {
  display: block;
  width: 100%;
  max-width: 260px;
  margin: 0 auto 10px;
  font-size: 1rem;
  height: 42px;
  padding: 6px 10px;
  border-radius: 8px;
  border: 2px solid #fff;
  text-align: center;
  background: rgba(255,255,255,0.15);
  color: #fff;
  box-sizing: border-box;
}

#reponse::placeholder {
  text-align: center;
  color: rgba(255,255,255,0.7);
}

/* âœ… Rendu LaTeX qui remplace parfaitement lâ€™input */
.reponse-latex {
  display: block;
  width: 100%;
  max-width: 260px;
  margin: 0 auto 10px;
  font-size: 1.1rem;
  padding: 6px 10px;
  text-align: center;
  border: 2px solid #fff;
  border-radius: 8px;
  background: rgba(255,255,255,0.2);
  color: #fff;
  position: relative;
  box-sizing: border-box;
}

.reponse-latex .close-btn {
  position: absolute;
  top: -8px;
  right: -8px;
  background: #e53935;
  color: #fff;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  line-height: 20px;
  text-align: center;
  font-size: 0.8rem;
  cursor: pointer;
}

/* âœ… Feedback toujours centrÃ©, stable et sans influence sur lâ€™input */
#feedback {
  display: block;
  width: 100%;
  max-width: 260px;
  margin: 0 auto;
  min-height: 1.4em;     /* garde la place mÃªme vide */
  font-size: 1rem;
  font-weight: bold;
  text-align: center;
  color: #fff;
  transition: color 0.3s ease, transform 0.2s ease;
}

#toggleQBtn,
#literalBtn {
  height: 36px;
  border-radius: 6px;
  font-size: 0.85rem;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
}

#toggleQBtn {
  background: #ffd54f;
  color: #000;
  padding: 0 14px;
  margin: 0; /* âœ… supprime le centrage automatique */
}

#literalBtn {
  background: #fff;
  color: #e53935;
  padding: 0 10px;
  width: auto;
  margin: 0; /* âœ… alignement horizontal */
}

#literalBtn[data-active="1"] {
  background: #ffd54f;
  color: #000;
}

.question-controls {
  display: flex;
  justify-content: center;
  align-items: center; /* âœ… aligne verticalement */
  gap: 8px;
  margin: 4px 0 6px 0;
}



  </style>
</head>
<body>
  <div id="geo"><div id="figure"></div></div>
  <div id="sidebar">

    <div class="section"><h3>Forme</h3><select id="forme"></select></div>
    <div class="section"><h3>ParamÃ¨tres</h3><div id="params"></div></div>
    <div class="section dual">
<div class="shuffleZone">
  <button id="themeBtn">ğŸ­</button>
  <button id="shuffleBtn">ğŸ”€</button>
  <button id="toggleModeBtn">ğŸ¨</button>

</div>

      <div id="modeZone"></div>
    </div>
    <div class="question-controls">
      <button id="literalBtn">ğŸ”¤</button>
  <button id="toggleQBtn">â“ Montrer la question</button>
  
</div>

    <div id="questionBlock" style="display:none;">
      <h3>Question Ã©lÃ¨ve</h3>
      <div id="question"></div>
<input type="text" id="reponse" placeholder="Votre rÃ©ponse" autocomplete="off">
      <button id="validerBtn">Valider</button>
      <div id="feedback"></div>
    </div>
  </div>

<script>
const geo=document.getElementById("geo"),figure=document.getElementById("figure"),
      formeSelect=document.getElementById("forme"),paramsDiv=document.getElementById("params"),
      shuffleBtn=document.getElementById("shuffleBtn"),modeZone=document.getElementById("modeZone"),
      questionDiv=document.getElementById("question"),reponseInput=document.getElementById("reponse"),
      validerBtn=document.getElementById("validerBtn"),feedbackDiv=document.getElementById("feedback"),
      toggleQBtn=document.getElementById("toggleQBtn"),questionBlock=document.getElementById("questionBlock");

const MARGIN=40,BAR_THICKNESS=MARGIN/2;
const BAR_MARGIN = 4; // ğŸ§© dÃ©calage extÃ©rieur uniforme pour toutes les barres
const themes=[["ğŸŸ¥", "ğŸŸ¦", "ğŸŸ©", "ğŸŸ¨"],["ğŸ“","ğŸŒ","ğŸ‡","ğŸ‘"],["ğŸ¸","ğŸ¦„","ğŸ²","ğŸ¦–"],["âš½ï¸","ğŸ€","ğŸˆ","ğŸ¥"],["ğŸ’™","ğŸ’š","ğŸ’œ","ğŸ–¤"],
              ["ğŸ©","ğŸª","ğŸ­","ğŸ¦"],["ğŸ¶","ğŸ±","ğŸ­","ğŸ»"],["ğŸ¼","ğŸ¨","ğŸµ","ğŸ¦Š"],["ğŸš—","ğŸï¸","ğŸš","ğŸš€"]];
let currentEmojiMap={"a":"ğŸ“"},targetCount=0,currentThemeIndex=0,currentParams={};

let useColorMode = false;
let useLiteralMode = false;
let refExpr = "";


// âš¡ï¸ Mettre true pour forcer Twemoji partout
const forceTwemoji = true; 

// DÃ©tection classique Apple
const isApple = /Mac|iPhone|iPad|iPod/.test(navigator.userAgent);

// DÃ©cision finale
const useTwemoji = forceTwemoji || !isApple;

/* === Figures === */
class Figure{constructor(label,params,types=["a"]){this.label=label;this.params=params;this.types=types;}
 getSize(p){return{m:1,n:1};} typeFn(r,c,p){return"a";} getBars(p,cs){return[];}}

class Carre extends Figure {
  constructor() {
    super("CarrÃ©", { c: { min: 1, max: 20, value: 5 } }, ["a"]);
  }

  getSize(p) {
    return { m: p.c, n: p.c };
  }

  typeFn(r, c, p) {
    return "a";
  }

  getBars(p, cs) {
    return [
      { side: "top", size: p.c * cs, text: p.c, param: "c", color: "#42a5f5" },
      { side: "left", size: p.c * cs, text: p.c, param: "c", color: "#ef5350" }
    ];
  }

  getLiteralExpressions(p) {
    return {
      total: "c*c",
      parts: { a: "c*c" }
    };
  }
}

class Rectangle extends Figure {
  constructor() {
    super(
      "Rectangle",
      { a: { min: 1, max: 40, value: 5 }, b: { min: 1, max: 40, value: 8 } },
      ["a"]
    );
  }

  getSize(p) {
    return { m: p.a, n: p.b };
  }

  typeFn(r, c, p) {
    return "a";
  }

  getBars(p, cs) {
    return [
      { side: "top", size: p.b * cs, text: p.b, param: "b", color: "#42a5f5", left: 0 },
      { side: "left", size: p.a * cs, text: p.a, param: "a", color: "#ef5350", top: 0 }
    ];
  }

  getLiteralExpressions(p) {
    return {
      total: "a*b",
      parts: { a: "a*b" }
    };
  }
}

class Damier extends Figure {
  constructor() {
    super(
      "Damier",
      { a: { min: 2, max: 40, value: 8 }, b: { min: 2, max: 40, value: 8 } },
      ["a", "b"]
    );
  }

  getSize(p) {
    return { m: p.a, n: p.b };
  }

  typeFn(r, c, p) {
    return (r + c) % 2 ? "a" : "b";
  }

  getBars(p, cs) {
    return [
      { side: "top", size: p.b * cs, text: p.b, param: "b", color: "#42a5f5" },
      { side: "left", size: p.a * cs, text: p.a, param: "a", color: "#ef5350" }
    ];
  }

getLiteralExpressions(p) {
  // ğŸŸ© Damier : alternance, une couleur a une case de plus si a*b est impair
  const isOdd = (p.a * p.b) % 2 === 1;

  return {
    total: "a*b",
    parts: {
      a: isOdd ? "(a*b + 1)/2" : "a*b/2",
      b: isOdd ? "(a*b - 1)/2" : "a*b/2"
    }
  };
}

}

class CarreBordure1 extends Figure {
  constructor() {
    super(
      "CarrÃ© bordure (1)",
      { c: { min: 3, max: 40, value: 6 } },
      ["a", "b"]
    );
  }

  getSize(p) {
    return { m: p.c, n: p.c };
  }

  typeFn(r, c, p) {
    // ğŸ”² Bordure d'Ã©paisseur fixe = 1
    return (r === 0 || r === p.c - 1 || c === 0 || c === p.c - 1) ? "a" : "b";
  }

  getBars(p, cs) {
    return [
      { side: "top", size: p.c * cs, text: p.c, param: "c", color: "#42a5f5" },
      { side: "left", size: p.c * cs, text: p.c, param: "c", color: "#ef5350" }
    ];
  }

  getLiteralExpressions(p) {
    return {
      total: "c*c",
      parts: {
        a: "4*(c-1)",
        b: "(c-2)*(c-2)"
      }
    };
  }
}


class CarreBordure extends Figure {
  constructor() {
    super(
      "CarrÃ© bordure",
      { c: { min: 3, max: 40, value: 7 }, b: { min: 1, max: 10, value: 2 } },
      ["a", "b"]
    );
  }

  getSize(p) {
    return { m: p.c, n: p.c };
  }

  typeFn(r, c, p) {
    // ğŸŸ© La bordure est de type "a", le centre de type "b"
    return (r < p.b || r >= p.c - p.b || c < p.b || c >= p.c - p.b) ? "a" : "b";
  }

  getBars(p, cs) {
    const gridW = p.c * cs;
    const gridH = p.c * cs;
    const plateauLeft = MARGIN / 2;
    const plateauTop = MARGIN / 2;

    const inside = p.b * cs; // distance du bord intÃ©rieur

    return [
      // === BARRES C (dimensions du carrÃ©) ===
      { side: "top",  size: gridW, text: p.c, param: "c", color: "#42a5f5", left: 0, top: 0 }, // haut
      { side: "left", size: gridH, text: p.c, param: "c", color: "#ef5350", left: 0, top: 0 }, // gauche

      // === BARRES B (Ã©paisseur de bordure) ===
      // En bas : deux horizontales, bien calÃ©es Ã  gauche et droite
      {
        side: "top",
        size: p.b * cs,
        text: p.b,
        param: "b",
        color: "#90caf9",
        absoluteLeft: plateauLeft,
        absoluteTop: plateauTop + gridH + 4 // sous la figure
      },
      {
        side: "top",
        size: p.b * cs,
        text: p.b,
        param: "b",
        color: "#90caf9",
        absoluteLeft: plateauLeft + gridW - p.b * cs,
        absoluteTop: plateauTop + gridH + 4
      },

      // Ã€ droite : deux verticales, bien calÃ©es en haut et en bas
      {
        side: "left",
        size: p.b * cs,
        text: p.b,
        param: "b",
        color: "#ef9a9a",
        absoluteLeft: plateauLeft + gridW + 4, // Ã  droite du carrÃ©
        absoluteTop: plateauTop
      },
      {
        side: "left",
        size: p.b * cs,
        text: p.b,
        param: "b",
        color: "#ef9a9a",
        absoluteLeft: plateauLeft + gridW + 4,
        absoluteTop: plateauTop + gridH - p.b * cs
      }
    ];
  }

  adjustParams(p) {
    const np = { ...p };
    const maxB = Math.floor((p.c - 1) / 2);
    if (np.b > maxB) np.b = maxB;
    return { ...np, _constraints: { b: { min: 1, max: maxB } } };
  }

  getLiteralExpressions(p) {
    return {
      total: "c*c",
      parts: {
        a: "4*b*(c-b)",
        b: "(c-2*b)*(c-2*b)"
      }
    };
  }
}




class TriangleDiagonal extends Figure {
  constructor() {
    super(
      "Triangle diagonal",
      { c: { min: 2, max: 40, value: 6 } },
      ["a", "b", "c"]
    );
  }

  getSize(p) {
    return { m: p.c, n: p.c };
  }

  typeFn(r, c, p) {
    if (c === r) return "a";
    if (c < r) return "b";
    return "c";
  }

  getBars(p, cs) {
    return [
      { side: "top", size: p.c * cs, text: p.c, param: "c", color: "#42a5f5" },
      { side: "left", size: p.c * cs, text: p.c, param: "c", color: "#ef5350" }
    ];
  }

  getLiteralExpressions(p) {
    // ğŸ§© Triangle diagonal : moitiÃ© dâ€™un carrÃ© de cÃ´tÃ© c
    return {
      total: "c*c",
      parts: {
        a: "c",         // la diagonale elle-mÃªme (fine ligne)
        b: "(c*c-c)/2",     // zone sous la diagonale
        c: "(c*c-c)/2"      // zone au-dessus de la diagonale
      }
    };
  }
}

class XFigure extends Figure {
  constructor() {
    super("Croix (X)", { c: { min: 3, max: 39, value: 7 } }, ["a", "b"]);
  }

  getSize(p) {
    return { m: p.c, n: p.c };
  }

  typeFn(r, c, p) {
    return (r === c || r + c === p.c - 1) ? "a" : "b";
  }

  getBars(p, cs) {
    return [
      { side: "top", size: p.c * cs, text: p.c, param: "c", color: "#42a5f5" },
      { side: "left", size: p.c * cs, text: p.c, param: "c", color: "#ef5350" }
    ];
  }

  adjustParams(p) {
    const np = { ...p };
    if (np.c < 3) np.c = 3;
    return np;
  }

  getLiteralExpressions(p) {
    const crossExpr = (p.c % 2 === 0) ? "2*c" : "2*c - 1";
    const restExpr = `(c*c - (${crossExpr}))`;

    return {
      total: "c*c",
      parts: {
        a: crossExpr,
        b: restExpr
      }
    };
  }
}


class CroixCentrale extends Figure {
  constructor() {
    super(
      "Croix centrale (type drapeau)",
      {
        a: { min: 4, max: 60, value: 20 }, // largeur totale
        b: { min: 4, max: 60, value: 15 }, // hauteur totale
        c: { min: 1, max: 20, value: 3 },  // Ã©paisseur de la croix
        x: { min: 0, max: 20, value: 0 },  // position horizontale
        y: { min: 0, max: 20, value: 0 }   // position verticale
      },
      ["croix", "fond"]
    );
  }

  getSize(p) {
    return { m: p.b, n: p.a };
  }

  typeFn(row, col, p) {
    const vStart = p.x;
    const hStart = p.y;
    const inV = col >= vStart && col < vStart + p.c;
    const inH = row >= hStart && row < hStart + p.c;
    return (inV || inH) ? "croix" : "fond";
  }

  getBars(p, cs) {
    const gridW = p.a * cs;
    const gridH = p.b * cs;
    const plateauLeft = MARGIN / 2;
    const plateauTop = MARGIN / 2;

    return [
      // ğŸ”µ largeur totale a
      { side: "top", size: gridW, text: p.a, param: "a", color: "#42a5f5", left: 0 },
      // ğŸ”´ hauteur totale b
      { side: "left", size: gridH, text: p.b, param: "b", color: "#ef5350", top: 0 },
      // ğŸŸ£ Ã©paisseur de la croix c (horizontale)
      {
        side: "top",
        size: p.c * cs,
        text: p.c,
        param: "c",
        color: "#1e88e5",
        absoluteLeft: Math.round(plateauLeft + p.x * cs),
        absoluteTop: Math.round(plateauTop + gridH)
      },
      // ğŸŸ¡ Ã©paisseur de la croix c (verticale)
      {
        side: "left",
        size: p.c * cs,
        text: p.c,
        param: "c",
        color: "#c62828",
        absoluteLeft: Math.round(plateauLeft + gridW),
        absoluteTop: Math.round(plateauTop + p.y * cs)
      }
    ];
  }

  adjustParams(p) {
    const np = { ...p };
    if (np.c >= np.a) np.c = np.a - 1;
    if (np.c >= np.b) np.c = np.b - 1;
    if (np.c < 1) np.c = 1;

    if (np.x === 0) np.x = Math.floor((np.a - np.c) / 2);
    if (np.y === 0) np.y = Math.floor((np.b - np.c) / 2);

    return {
      ...np,
      _constraints: {
        c: { min: 1, max: Math.min(np.a - 1, np.b - 1) },
        x: { min: 0, max: np.a - np.c },
        y: { min: 0, max: np.b - np.c }
      }
    };
  }

getLiteralExpressions(p) {
  // ğŸ Drapeau : croix centrale de largeur c dans un rectangle aÃ—b
  const croix = "a*c + b*c - c*c";
  const fond = "a*b - (a*c + b*c - c*c)";
  const total = "a*b"; // cohÃ©rence littÃ©rale avec la somme des zones

  return {
    total,
    parts: { croix, fond }
  };
}

}






class Distributivite extends Figure {
  constructor() {
    super(
      "DistributivitÃ© simple",
      {
        a: { min: 1, max: 30, value: 6 },
        b: { min: 1, max: 20, value: 4 },
        c: { min: 1, max: 20, value: 5 }
      },
      ["ab", "ac"]
    );
  }

  getSize(p) {
    return { m: p.a, n: p.b + p.c };
  }

  typeFn(row, col, p) {
    return col < p.b ? "ab" : "ac";
  }

  getBars(p, cellSize) {
    return [
      { side: "top", size: p.b * cellSize, text: p.b, param: "b", color: "#42a5f5", left: 0 },
      { side: "top", size: p.c * cellSize, text: p.c, param: "c", color: "#1e88e5", left: p.b * cellSize },
      { side: "left", size: p.a * cellSize, text: p.a, param: "a", color: "#ef5350", top: 0 }
    ];
  }

  // ğŸ§® Expressions littÃ©rales (a(b + c) = ab + ac)
  getLiteralExpressions(p) {
    return {
      total: "a*(b + c)",
      parts: {
        ab: "a*b",
        ac: "a*c"
      }
    };
  }
}


class DoubleDistributivite extends Figure {
  constructor() {
    super(
      "Double distributivitÃ©",
      {
        a: { min: 1, max: 30, value: 10 },
        b: { min: 1, max: 10, value: 3 },
        c: { min: 1, max: 30, value: 10 },
        d: { min: 1, max: 10, value: 5 }
      },
      ["ac", "ad", "bc", "bd"]
    );
  }

  getSize(p) {
    return { m: p.a + p.b, n: p.c + p.d };
  }

  typeFn(r, c, p) {
    const isA = r < p.a;
    const isC = c < p.c;
    if (isA && isC) return "ac";
    if (isA && !isC) return "ad";
    if (!isA && isC) return "bc";
    return "bd";
  }

  getBars(p, cs) {
    return [
      { side: "top", size: p.c * cs, text: p.c, param: "c", color: "#42a5f5", left: 0 },
      { side: "top", size: p.d * cs, text: p.d, param: "d", color: "#1e88e5", left: p.c * cs },
      { side: "left", size: p.a * cs, text: p.a, param: "a", color: "#ef5350", top: 0 },
      { side: "left", size: p.b * cs, text: p.b, param: "b", color: "#c62828", top: p.a * cs }
    ];
  }

  // ğŸ§® Expressions littÃ©rales : (a+b)(c+d) = ac + ad + bc + bd
  getLiteralExpressions(p) {
    return {
      total: "(a + b)*(c + d)",
      parts: {
        ac: "a*c",
        ad: "a*d",
        bc: "b*c",
        bd: "b*d"
      }
    };
  }
}


class IRCarre extends Figure {
  constructor() {
    super(
      "IdentitÃ© remarquable (a+b)Â²",
      {
        a: { min: 1, max: 30, value: 10 },
        b: { min: 1, max: 10, value: 3 }
      },
      ["aa", "ab", "bb"]
    );
  }

  getSize(p) {
    return { m: p.a + p.b, n: p.a + p.b };
  }

  typeFn(r, c, p) {
    const isArow = r < p.a;
    const isAcol = c < p.a;
    if (isArow && isAcol) return "aa";        // carrÃ© supÃ©rieur gauche
    if (!isArow && !isAcol) return "bb";      // carrÃ© infÃ©rieur droit
    return "ab";                              // rectangles latÃ©raux
  }

  getBars(p, cs) {
    return [
      // ğŸ”¹ Barres horizontales (haut)
      { side: "top", size: p.a * cs, text: p.a, param: "a", color: "#42a5f5", left: 0 },
      { side: "top", size: p.b * cs, text: p.b, param: "b", color: "#1e88e5", left: p.a * cs },

      // ğŸ”¹ Barres verticales (gauche)
      { side: "left", size: p.a * cs, text: p.a, param: "a", color: "#ef5350", top: 0 },
      { side: "left", size: p.b * cs, text: p.b, param: "b", color: "#c62828", top: p.a * cs }
    ];
  }

  // ğŸ§® Expressions littÃ©rales : (a+b)Â² = aÂ² + 2ab + bÂ²
  getLiteralExpressions(p) {
    return {
      total: "(a + b)*(a + b)",
      parts: {
        aa: "a*a",
        ab: "2*a*b",
        bb: "b*b"
      }
    };
  }
}


const figureRegistry = {
  carre: new Carre(),
  rectangle: new Rectangle(),
  damier: new Damier(),
  carreBordure1: new CarreBordure1(),
  carreBordure: new CarreBordure(),
  triangleDiagonal: new TriangleDiagonal(),
  x: new XFigure(),
  croixCentrale: new CroixCentrale(),
  distributivite: new Distributivite(),   // ğŸ‘ˆ ajout ici
  doubleDistributivite: new DoubleDistributivite(),
  irCarre: new IRCarre()
};

/* === Emojis === */
function pickTheme(i) {
  currentThemeIndex = i % themes.length;
  return themes[currentThemeIndex].slice();
}

function applyThemeToTypes(types, force = false) {
  let emojis = pickTheme(currentThemeIndex).slice();
  if (force) emojis.sort(() => Math.random() - 0.5);

  const newMap = {};
  types.forEach((t, i) => {
    newMap[t] = emojis[i % emojis.length];
  });
  currentEmojiMap = newMap;
}

function buildParamsUI(figName) {
  // ğŸ§¹ Nettoyage initial
  paramsDiv.innerHTML = "";
  modeZone.innerHTML = "";

  const fig = figureRegistry[figName];

  // ğŸ§© Appliquer un thÃ¨me (emoji) pour les types si on est en mode emoji
if (!useColorMode) {
  applyThemeToTypes(fig.types, true);
}

  // ğŸ¨ Palette pour le mode couleur
const palette = {
  // --- Couleurs de base ---
  a: "#e53935",     // ğŸ”´ rouge vif
  b: "#1e88e5",     // ğŸ”µ bleu saturÃ©
  c: "#43a047",     // ğŸŸ¢ vert profond
  d: "#fbc02d",     // ğŸŸ¡ jaune chaud

  // --- Alias pour les produits (mÃªmes teintes rÃ©utilisÃ©es) ---
  ab: "#1e88e5",    // mÃªme que b
  ac: "#43a047",    // mÃªme que c
  ad: "#fbc02d",    // mÃªme que d
  bc: "#43a047",    // idem c
  bd: "#fbc02d",    // idem d
  aa: "#e53935",    // idem a
  bb: "#1e88e5",    // idem b

  // --- SpÃ©cifiques Ã  dâ€™autres figures ---
  fond: "#90caf9",  // bleu clair
  croix: "#8e24aa"  // violet profond
};



  // ğŸŸ¦ CrÃ©ation des boutons de type
  fig.types.forEach(t => {
    const btn = document.createElement("button");
    btn.dataset.type = t;
    btn.classList.add("emoji-toggle");
    btn.dataset.active = "1";

    if (useColorMode) {
      // ğŸ¨ Mode couleur â†’ fond colorÃ©, pas dâ€™emoji
      btn.style.background = palette[t] || "#ccc";
      btn.textContent = "";
    } else {
      // ğŸ“ Mode emoji â†’ emoji dans le bouton
      btn.style.background = "#fff";
      btn.textContent = currentEmojiMap[t];
    }

    // âœ¨ FantÃ´me : clic pour activer/dÃ©sactiver le type
btn.addEventListener("click", () => {
  btn.dataset.active = btn.dataset.active === "1" ? "0" : "1";
  btn.style.opacity = btn.dataset.active === "1" ? "1" : "0.4";

  // ğŸ”„ Redessine la figure
  dessinerFigure(figName, currentParams);

  // ğŸ”¤ Si on est en mode littÃ©ral, on recalcule la question Ã  jour
  if (useLiteralMode) poserQuestion(figName, currentParams);
});


    modeZone.appendChild(btn);
  });

  // ğŸ§® Interface des paramÃ¨tres
  const inputs = {};
  const container = document.createElement("div");
  container.className = "param-container";

  // Valeurs initiales
  let values = { ...currentParams };
  for (const [k, cfg] of Object.entries(fig.params)) {
    if (values[k] === undefined) values[k] = cfg.value;
  }
  if (fig.adjustParams) values = fig.adjustParams(values);

  // Champs pour chaque paramÃ¨tre
  for (const [key, cfg] of Object.entries(fig.params)) {
    const item = document.createElement("div");
    item.className = "param-item";

    const label = document.createElement("label");
    label.textContent = key + ":";

    const input = document.createElement("input");
    input.type = "number";
    input.min = cfg.min;
    input.max = cfg.max;
    input.value = values[key];
    input.step = 1;

    inputs[key] = input;
    item.appendChild(label);
    item.appendChild(input);
    container.appendChild(item);
  }

  if (container.children.length > 0) paramsDiv.appendChild(container);

  // ğŸŒ€ Mise Ã  jour dynamique lors dâ€™un changement de paramÃ¨tre
  function update() {
    const newValues = {};
    for (const [k, inp] of Object.entries(inputs)) {
      newValues[k] = parseInt(inp.value);
    }

    let normalized = newValues;
    if (fig.adjustParams) normalized = fig.adjustParams(newValues);

    if (normalized._constraints) {
      for (const [k, cons] of Object.entries(normalized._constraints)) {
        if (inputs[k]) {
          inputs[k].min = cons.min;
          inputs[k].max = cons.max;
          if (normalized[k] < cons.min) normalized[k] = cons.min;
          if (normalized[k] > cons.max) normalized[k] = cons.max;
          inputs[k].value = normalized[k];
        }
      }
    }

    // âœ… RÃ©initialisation de la zone de rÃ©ponse et feedback
    resetReponseZone();

    dessinerFigure(figName, normalized);
    currentParams = { ...normalized };
  }

  // ğŸ“¡ Lier lâ€™Ã©vÃ©nement sur tous les inputs
  for (const inp of Object.values(inputs)) {
    inp.addEventListener("input", update);
  }

  // ğŸ–¼ï¸ Dessin initial
  update();
}




/* === Dessin === */
function createCell(type, cs, p) {
  const cell = document.createElement("div");
  cell.className = `cell type-${type}`;
  cell.style.width = cs + "px";
  cell.style.height = cs + "px";
  cell.style.lineHeight = cs + "px";
  cell.style.fontSize = (cs * 0.75) + "px";

  // ğŸ” VÃ©rifie l'Ã©tat du bouton pour ce type
  const btn = document.querySelector(`#modeZone button[data-type="${type}"]`);
  const isActive = !btn || btn.dataset.active === "1";

  if (useColorMode) {
    // ğŸ¨ Mode couleur
const palette = {
  // --- Couleurs de base ---
  a: "#e53935",     // ğŸ”´ rouge vif
  b: "#1e88e5",     // ğŸ”µ bleu saturÃ©
  c: "#43a047",     // ğŸŸ¢ vert profond
  d: "#fbc02d",     // ğŸŸ¡ jaune chaud

  // --- Alias pour les produits (mÃªmes teintes rÃ©utilisÃ©es) ---
  ab: "#1e88e5",    // mÃªme que b
  ac: "#43a047",    // mÃªme que c
  ad: "#fbc02d",    // mÃªme que d
  bc: "#43a047",    // idem c
  bd: "#fbc02d",    // idem d
  aa: "#e53935",    // idem a
  bb: "#1e88e5",    // idem b

  // --- SpÃ©cifiques Ã  dâ€™autres figures ---
  fond: "#90caf9",  // bleu clair
  croix: "#8e24aa"  // violet profond
};



    cell.style.background = palette[type] || "#ccc";
    cell.style.border = "1px solid rgba(255,255,255,0.8)";
    cell.textContent = "";
  } else {
    // ğŸ“ Mode emoji
    cell.style.background = "transparent";
    cell.style.border = "none";
    cell.textContent = currentEmojiMap[type] || "";
  }

  // ğŸ‘» Appliquer le fantÃ´me quelle que soit la version
  if (!isActive) {
    cell.classList.add("ghost");
    cell.style.filter = "grayscale(80%)";
    cell.style.opacity = "0.3";
  } else {
    cell.classList.remove("ghost");
    cell.style.filter = "none";
    cell.style.opacity = "1";
  }

  return cell;
}




function getCellContent(type,p){if(type==="fond")return"";const btn=document.querySelector(`#modeZone button[data-type="${type}"]`);if(btn&&btn.dataset.active==="0")return"";return currentEmojiMap[type]||"";}
function compterEmoji(figName,params){const fig=figureRegistry[figName];const{m,n}=fig.getSize(params);const counts={};for(let r=0;r<m;r++){for(let c=0;c<n;c++){const t=fig.typeFn(r,c,params);if(getCellContent(t,params)!==""){counts[t]=(counts[t]||0)+1;}}}return counts;}

function buildLiteralExpression(figName, params) {
  const fig = figureRegistry[figName];
  const exprs = fig.getLiteralExpressions(params);

  // Liste des boutons types
  const allTypes = fig.types;
  const visibles = allTypes.filter(t => {
    const btn = document.querySelector(`#modeZone button[data-type="${t}"]`);
    return !btn || btn.dataset.active === "1";
  });

  // ğŸ§  Si tous les types sont actifs â†’ total
  if (visibles.length === allTypes.length) {
    return exprs.total;
  }

  // ğŸ§© Sinon somme des parties visibles
  return visibles.map(t => exprs.parts[t]).join(" + ");
}







function poserQuestion(figName, params) {
  const counts = compterEmoji(figName, params);
  const total = Object.values(counts).reduce((a,b)=>a+b,0);
  targetCount = total;

  const fig = figureRegistry[figName];

if (useLiteralMode) {
  // ğŸ”¤ Mode littÃ©ral : on ne montre PAS la rÃ©ponse exacte
  const expr = buildLiteralExpression(figName, params);
  window.refExpr = expr; // ğŸ’¾ on garde la rÃ©fÃ©rence pour la validation

  questionDiv.textContent = "Expression littÃ©rale du nombre dâ€™emojis visibles :";
  reponseInput.placeholder = "";
} else {
  // ğŸ”¢ Mode numÃ©rique
  questionDiv.textContent = "Nombre dâ€™emojis visibles :";
  reponseInput.placeholder = "Votre rÃ©ponse";
}


  feedbackDiv.textContent = "";
  reponseInput.value = "";
}

function resetReponseZone() {
  // ğŸ” Si un rendu LaTeX est prÃ©sent, on le remplace par lâ€™input original
  const latexDiv = document.querySelector(".reponse-latex");
  if (latexDiv) {
    latexDiv.replaceWith(reponseInput);
  }

  // ğŸ§¹ RÃ©initialiser lâ€™input
  reponseInput.value = "";

  // ğŸ§¹ RÃ©initialiser le feedback
  feedbackDiv.textContent = "";
  feedbackDiv.style.color = "#fff";
}




function dessinerFigure(figName, params) {
  const fig = figureRegistry[figName];
  const { m: rows, n: cols } = fig.getSize(params);

  const W = geo.clientWidth;
  const H = geo.clientHeight;
  const GEO_MARGIN = 20;

  const usableW = W - 2 * GEO_MARGIN;
  const usableH = H - 2 * GEO_MARGIN;

  // ğŸ“ Taille d'une cellule
let cs = Math.min((usableW - MARGIN) / cols, (usableH - MARGIN) / rows);

// ğŸ§¹ Corrige les artefacts subpixel
const gridW = Math.round(cols * cs);
const gridH = Math.round(rows * cs);

// ğŸ“ Recalcule la taille rÃ©elle d'une cellule pour tomber pile
cs = gridW / cols;

const plateauW = gridW + MARGIN;
const plateauH = gridH + MARGIN;

  // ğŸ“ Origine du coin haut gauche du plateau
  const originX = GEO_MARGIN + (usableW - plateauW) / 2 + MARGIN / 2;
  const originY = GEO_MARGIN + (usableH - plateauH) / 2 + MARGIN / 2;

  // ğŸ“¦ CrÃ©ation ou rÃ©cupÃ©ration du plateau
  let plateau = document.getElementById("plateau");
  if (!plateau) {
    plateau = document.createElement("div");
    plateau.id = "plateau";
    geo.appendChild(plateau);
  }

  // ğŸ§¹ Nettoyage plateau (grille + barres prÃ©cÃ©dentes)
  plateau.innerHTML = "";
  plateau.style.width = plateauW + "px";
  plateau.style.height = plateauH + "px";
  plateau.style.left = Math.round(GEO_MARGIN + (usableW - plateauW) / 2) + "px";
  plateau.style.top = Math.round(GEO_MARGIN + (usableH - plateauH) / 2) + "px";
  plateau.style.position = "absolute";

  // ğŸŸ© Grille emoji
  const figDiv = document.createElement("div");
  figDiv.style.position = "absolute";
  figDiv.style.left = MARGIN / 2 + "px";
  figDiv.style.top = MARGIN / 2 + "px";
  figDiv.style.display = "grid";
  figDiv.style.gridTemplateColumns = `repeat(${cols}, ${cs}px)`;
  figDiv.style.gridTemplateRows = `repeat(${rows}, ${cs}px)`;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const type = fig.typeFn(r, c, params);
      const cell = createCell(type, cs, params);
      figDiv.appendChild(cell);
    }
  }

  plateau.appendChild(figDiv);

  // ğŸ“ Barres de mesure
  const bars = fig.getBars ? fig.getBars(params, cs) : [];

  bars.forEach(b => {
    const div = document.createElement("div");
    div.className = "bar " + b.side;
    div.style.background = b.color;
    div.textContent = useLiteralMode
  ? (b.param || b.text)    // ğŸ”¤ affiche la lettre si disponible
  : b.text;                // sinon affiche la valeur numÃ©rique

    div.style.position = "absolute";
    div.style.display = "flex";
    div.style.justifyContent = "center";
    div.style.alignItems = "center";

if (b.side === "top") {
  // âœ… DÃ©calage vertical vers l'extÃ©rieur uniquement
  div.style.left =
    (b.absoluteLeft !== undefined ? b.absoluteLeft : MARGIN / 2 + (b.left || 0)) + "px";
  div.style.top =
    (b.absoluteTop !== undefined
      ? b.absoluteTop
      : MARGIN / 2 - BAR_THICKNESS - BAR_MARGIN) + "px";

  div.style.width = b.size + "px";
  div.style.height = BAR_THICKNESS + "px";
}

if (b.side === "left") {
  // âœ… DÃ©calage horizontal vers l'extÃ©rieur, mais PAS verticalement
  div.style.left =
    (b.absoluteLeft !== undefined
      ? b.absoluteLeft
      : MARGIN / 2 - BAR_THICKNESS - BAR_MARGIN) + "px";
  div.style.top =
    (b.absoluteTop !== undefined
      ? b.absoluteTop
      : MARGIN / 2 + (b.top || 0)) + "px";

  div.style.width = BAR_THICKNESS + "px";
  div.style.height = b.size + "px";
}




    // âœ… IMPORTANT : on reste dans le plateau pour que le nettoyage fonctionne
    plateau.appendChild(div);
  });

  poserQuestion(figName, params);
  currentParams = { ...params };
}

/* === Events === */
for(const[name,fig]of Object.entries(figureRegistry)){const opt=document.createElement("option");opt.value=name;opt.textContent=fig.label;formeSelect.appendChild(opt);}
formeSelect.addEventListener("change",()=>buildParamsUI(formeSelect.value));
document.getElementById("themeBtn").addEventListener("click", () => {
  // ğŸ” Passe simplement au thÃ¨me suivant
  currentThemeIndex = (currentThemeIndex + 1) % themes.length;

  const figName = formeSelect.value;
  const oldParams = { ...currentParams };

  applyThemeToTypes(figureRegistry[figName].types);
  buildParamsUI(figName);
  dessinerFigure(figName, oldParams);
});

shuffleBtn.addEventListener("click", () => {
  const figName = formeSelect.value;
  const fig = figureRegistry[figName];

  // âœ… Sauvegarde des valeurs actuelles
  const oldParams = { ...currentParams };

  // Shuffle du thÃ¨me
  applyThemeToTypes(fig.types, true);

  // Reconstruit lâ€™UI
  buildParamsUI(figName);

  // âœ… Restaure les anciennes valeurs si possible
  dessinerFigure(figName, oldParams);
});

function isEquivalent(exprUser, exprRef) {
  // ğŸ§® Normalisation complÃ¨te avant Ã©valuation
  function normalize(expr) {
    return expr
      // --- puissances ---
      .replace(/([a-dA-D])\^2\b/g, "($1*$1)")                   // a^2 â†’ (a*a)
      .replace(/\(([^()]+)\)\^2\b/g, "($1)*($1)")               // (a+b)^2 â†’ (a+b)*(a+b)
      .replace(/([a-dA-D])Â²\b/g, "($1*$1)")                     // aÂ² â†’ (a*a)
      .replace(/\(([^()]+)\)Â²\b/g, "($1)*($1)")                 // (a+b)Â² â†’ (a+b)*(a+b)
      .replace(/([a-dA-D])\^3\b/g, "($1*$1*$1)")                // a^3 â†’ (a*a*a)
      .replace(/\(([^()]+)\)\^3\b/g, "($1)*($1)*($1)")          // (a+b)^3 â†’ (a+b)*(a+b)*(a+b)
      .replace(/([a-dA-D])Â³\b/g, "($1*$1*$1)")                  // aÂ³ â†’ (a*a*a)
      .replace(/\(([^()]+)\)Â³\b/g, "($1)*($1)*($1)")            // (a+b)Â³ â†’ (a+b)*(a+b)*(a+b)
      // --- produits implicites ---
      .replace(/(\d)([a-dA-D])/g, "$1*$2")                      // 3a â†’ 3*a
      .replace(/([a-dA-D])\(/g, "$1*(")                         // a(b+c) â†’ a*(b+c)
      .replace(/\)([a-dA-D])/g, ")*$1")                         // (a+b)c â†’ (a+b)*c
      .replace(/([a-dA-D])([a-dA-D])/g, "$1*$2");               // ab â†’ a*b
  }

  const cleanUser = normalize(exprUser);
  const cleanRef  = normalize(exprRef);

  try {
    const testValues = [2, 3, 5, 7];
    const vars = ["a", "b", "c", "d"];

    for (const a of testValues) {
      for (const b of testValues) {
        for (const c of testValues) {
          for (const d of testValues) {
            const userVal = Function("a,b,c,d", `return (${cleanUser});`)(a, b, c, d);
            const refVal  = Function("a,b,c,d", `return (${cleanRef});`)(a, b, c, d);
            if (Math.abs(userVal - refVal) > 1e-9) return false;
          }
        }
      }
    }
    return true;
  } catch (e) {
    console.warn("Erreur dans isEquivalent:", e);
    return false;
  }
}




validerBtn.addEventListener("click", () => {

  // === ğŸ§® MODE LITTÃ‰RAL ===
  if (useLiteralMode) {
    const exprL = reponseInput.value.trim();
    const ref = (window.refExpr || "").trim();

    if (exprL === "") {
      feedbackDiv.textContent = "ğŸ’¡ Essaie dâ€™Ã©crire une expression avec a, b, câ€¦";
      feedbackDiv.style.color = "#ffd54f";
      return;
    }

    // ğŸ” Test d'Ã©quivalence symbolique sur plusieurs valeurs
    if (isEquivalent(exprL, ref)) {
      feedbackDiv.textContent = "âœ… Bien jouÃ©, ton expression est cohÃ©rente !";
      feedbackDiv.style.color = "#0f0";
    } else {
      feedbackDiv.textContent = "âŒ Pas encore, observe bien les zones visiblesâ€¦";
      feedbackDiv.style.color = "#ff0";
    }

    return; // ğŸ”’ on arrÃªte ici â€” pas de calcul numÃ©rique
  }

  // === ğŸ”¢ MODE NUMÃ‰RIQUE ===
  const expr = reponseInput.value.trim();
  let val;

  try {
    val = Function(`"use strict"; return (${expr});`)();
  } catch (e) {
    feedbackDiv.textContent = "âš ï¸ Expression invalide.";
    feedbackDiv.style.color = "#ff0";
    return;
  }

  // ğŸ“ CrÃ©ation du rendu LaTeX
  const latexDiv = document.createElement("div");
  latexDiv.className = "reponse-latex";
  latexDiv.innerHTML = `\\( ${expr.replace(/\*/g, '\\times ')} \\)`;

  if (Number(val) !== targetCount) {
    // âŒ Faux : proposer de rÃ©essayer
    const closeBtn = document.createElement("div");
    closeBtn.className = "close-btn";
    closeBtn.textContent = "âœ–";
    closeBtn.addEventListener("click", () => {
      latexDiv.replaceWith(reponseInput);
      reponseInput.value = "";
      feedbackDiv.textContent = "";
      feedbackDiv.style.color = "#fff";
      reponseInput.focus();
    });
    latexDiv.appendChild(closeBtn);

    feedbackDiv.textContent = "âŒ Faux ! RÃ©essaie.";
    feedbackDiv.style.color = "#ff0";
  } else {
    // âœ… Bravo : on confirme la valeur trouvÃ©e
    feedbackDiv.textContent = `âœ… Bravo ! La valeur finale est ${targetCount}.`;
    feedbackDiv.style.color = "#0f0";
  }

  // Remplacer lâ€™input par le rendu LaTeX
  reponseInput.replaceWith(latexDiv);

  // Rendu MathJax
  if (window.MathJax) {
    MathJax.typesetPromise();
  }
});



document.getElementById("toggleModeBtn").addEventListener("click", () => {
  useColorMode = !useColorMode;
  console.log("ğŸ”„ Nouveau mode :", useColorMode ? "Couleur" : "Emoji");

  // âœ… Reconstruit les boutons selon le mode
  buildParamsUI(formeSelect.value);

  // âœ… Redessine la figure dans le bon mode
  dessinerFigure(formeSelect.value, currentParams);

  // âœ… Met Ã  jour le texte du bouton
  document.getElementById("toggleModeBtn").textContent = useColorMode ? "ğŸ”¤ Emoji" : "ğŸ¨ Couleur";
});



// ğŸ§¹ DÃ¨s que lâ€™Ã©lÃ¨ve modifie sa rÃ©ponse, on efface le feedback
reponseInput.addEventListener("input", () => {
  feedbackDiv.textContent = "";
  feedbackDiv.style.color = "#fff";
});

reponseInput.addEventListener("keydown",e=>{if(e.key==="Enter")validerBtn.click();});

const toggleModeBtn = document.getElementById("toggleModeBtn");

// ğŸ§¹ on supprime tout Ã©ventuel ancien listener (Ã©vite le double dÃ©clenchement)
toggleModeBtn.replaceWith(toggleModeBtn.cloneNode(true));
const newToggleModeBtn = document.getElementById("toggleModeBtn");

newToggleModeBtn.addEventListener("click", () => {
  useColorMode = !useColorMode;

  buildParamsUI(formeSelect.value);

  const fig = figureRegistry[formeSelect.value];
  let normalized = { ...currentParams };
  if (fig.adjustParams) normalized = fig.adjustParams(normalized);

  dessinerFigure(formeSelect.value, normalized);
  currentParams = { ...normalized };

  newToggleModeBtn.textContent = useColorMode ? "ğŸ˜€" : "ğŸ¨";
});

// --- Gestion du bouton "Montrer la question" ---
toggleQBtn.addEventListener("click", () => {
  const visible = questionBlock.style.display === "block";
  questionBlock.style.display = visible ? "none" : "block";
  toggleQBtn.textContent = visible ? "â“ Montrer la question" : "âŒ Cacher la question";
});

const literalBtn = document.getElementById("literalBtn");
literalBtn.style.opacity = "0.5"; // ğŸ”˜ initialement Ã©teint = pas littÃ©ral

literalBtn.addEventListener("click", () => {
  useLiteralMode = !useLiteralMode;

  // ğŸ’¡ cohÃ©rence visuelle
  literalBtn.style.opacity = useLiteralMode ? "1" : "0.5";
  literalBtn.style.background = useLiteralMode ? "#ffd54f" : "#fff"; // petit effet visuel
  literalBtn.style.color = useLiteralMode ? "#000" : "#e53935";

  dessinerFigure(formeSelect.value, currentParams);
  poserQuestion(formeSelect.value, currentParams); // ğŸ’¬ met la question Ã  jour
  console.log("ğŸ”¤ Mode littÃ©ral :", useLiteralMode);
});


window.addEventListener("resize",()=>{const figName=formeSelect.value;if(!figName||!figureRegistry[figName])return;dessinerFigure(figName,currentParams);});
buildParamsUI("carre");
</script>
</body>
</html>
